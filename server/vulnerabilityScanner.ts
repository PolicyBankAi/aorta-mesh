import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import { securityLogger } from './security';

const execAsync = promisify(exec);

/**
 * Vulnerability Scanning Service
 * Automated security checks for dependencies and container images
 */

export interface VulnerabilityReport {
  timestamp: string;
  scanType: 'npm' | 'container' | 'dependency';
  vulnerabilities: {
    critical: number;
    high: number;
    moderate: number;
    low: number;
    info: number;
  };
  details: any[];
  passed: boolean;
}

/**
 * Run npm audit and return vulnerability report
 */
export async function runNpmAudit(): Promise<VulnerabilityReport> {
  const report: VulnerabilityReport = {
    timestamp: new Date().toISOString(),
    scanType: 'npm',
    vulnerabilities: {
      critical: 0,
      high: 0,
      moderate: 0,
      low: 0,
      info: 0
    },
    details: [],
    passed: false
  };

  try {
    // Run npm audit with JSON output
    const { stdout } = await execAsync('npm audit --json', {
      cwd: process.cwd()
    });
    
    const auditResult = JSON.parse(stdout);
    
    if (auditResult.metadata && auditResult.metadata.vulnerabilities) {
      const vulns = auditResult.metadata.vulnerabilities;
      report.vulnerabilities = {
        critical: vulns.critical || 0,
        high: vulns.high || 0,
        moderate: vulns.moderate || 0,
        low: vulns.low || 0,
        info: vulns.info || 0
      };
    }
    
    if (auditResult.vulnerabilities) {
      report.details = Object.values(auditResult.vulnerabilities);
    }
    
    // Consider passed if no critical or high vulnerabilities
    report.passed = report.vulnerabilities.critical === 0 && report.vulnerabilities.high === 0;
    
    securityLogger.info('NPM Audit completed', {
      vulnerabilities: report.vulnerabilities,
      passed: report.passed
    });
    
  } catch (error) {
    securityLogger.error('NPM Audit failed', {
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    
    report.details.push({
      error: 'Failed to run npm audit',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
  
  return report;
}

/**
 * Check for outdated dependencies
 */
export async function checkOutdatedDependencies(): Promise<VulnerabilityReport> {
  const report: VulnerabilityReport = {
    timestamp: new Date().toISOString(),
    scanType: 'dependency',
    vulnerabilities: { critical: 0, high: 0, moderate: 0, low: 0, info: 0 },
    details: [],
    passed: true
  };

  try {
    const { stdout } = await execAsync('npm outdated --json', {
      cwd: process.cwd()
    });
    
    if (stdout.trim()) {
      const outdated = JSON.parse(stdout);
      report.details = Object.entries(outdated).map(([pkg, info]: [string, any]) => ({
        package: pkg,
        current: info.current,
        wanted: info.wanted,
        latest: info.latest,
        location: info.location
      }));
      
      // Mark as info-level issues
      report.vulnerabilities.info = Object.keys(outdated).length;
    }
    
    securityLogger.info('Dependency check completed', {
      outdatedPackages: report.details.length
    });
    
  } catch (error) {
    // npm outdated returns exit code 1 when outdated packages exist
    securityLogger.warn('Dependency check warning', {
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
  
  return report;
}

/**
 * Generate security report combining all scans
 */
export async function generateSecurityReport(): Promise<{
  timestamp: string;
  reports: VulnerabilityReport[];
  overallStatus: 'passed' | 'warning' | 'failed';
  recommendations: string[];
}> {
  const reports: VulnerabilityReport[] = [];
  const recommendations: string[] = [];
  
  // Run npm audit
  const npmReport = await runNpmAudit();
  reports.push(npmReport);
  
  // Check outdated dependencies
  const depReport = await checkOutdatedDependencies();
  reports.push(depReport);
  
  // Determine overall status
  let overallStatus: 'passed' | 'warning' | 'failed' = 'passed';
  
  for (const report of reports) {
    if (!report.passed || report.vulnerabilities.critical > 0) {
      overallStatus = 'failed';
      break;
    } else if (report.vulnerabilities.high > 0 || report.vulnerabilities.moderate > 0) {
      overallStatus = 'warning';
    }
  }
  
  // Generate recommendations
  if (npmReport.vulnerabilities.critical > 0) {
    recommendations.push('ðŸ”´ CRITICAL: Update packages with critical vulnerabilities immediately');
  }
  if (npmReport.vulnerabilities.high > 0) {
    recommendations.push('ðŸŸ¡ HIGH: Review and update packages with high vulnerabilities');
  }
  if (npmReport.vulnerabilities.moderate > 0) {
    recommendations.push('ðŸŸ  MODERATE: Consider updating packages with moderate vulnerabilities');
  }
  if (depReport.details.length > 0) {
    recommendations.push('ðŸ“¦ INFO: Consider updating outdated dependencies');
  }
  if (overallStatus === 'passed') {
    recommendations.push('âœ… All security checks passed');
  }
  
  const securityReport = {
    timestamp: new Date().toISOString(),
    reports,
    overallStatus,
    recommendations
  };
  
  // Save report to file
  await saveSecurityReport(securityReport);
  
  securityLogger.info('Security report generated', {
    overallStatus,
    totalVulnerabilities: reports.reduce((sum, r) => 
      sum + Object.values(r.vulnerabilities).reduce((a, b) => a + b, 0), 0
    )
  });
  
  return securityReport;
}

/**
 * Save security report to file
 */
async function saveSecurityReport(report: any): Promise<void> {
  try {
    const reportsDir = path.join(process.cwd(), 'logs', 'security-reports');
    await fs.mkdir(reportsDir, { recursive: true });
    
    const filename = `security-report-${new Date().toISOString().split('T')[0]}.json`;
    const filepath = path.join(reportsDir, filename);
    
    await fs.writeFile(filepath, JSON.stringify(report, null, 2));
    
    securityLogger.info('Security report saved', { filepath });
  } catch (error) {
    securityLogger.error('Failed to save security report', {
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}

/**
 * Schedule automated vulnerability scans
 */
export function scheduleVulnerabilityScans(): void {
  // Run security scan on startup
  setTimeout(() => {
    generateSecurityReport().catch(error => {
      securityLogger.error('Scheduled security scan failed', {
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    });
  }, 10000); // Wait 10 seconds after startup
  
  // Run daily security scans (in production)
  if (process.env.NODE_ENV === 'production') {
    setInterval(() => {
      generateSecurityReport().catch(error => {
        securityLogger.error('Daily security scan failed', {
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      });
    }, 24 * 60 * 60 * 1000); // 24 hours
  }
  
  securityLogger.info('Vulnerability scanning scheduled');
}