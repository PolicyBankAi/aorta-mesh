import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs/promises";
import path from "path";
import { securityLogger } from "./security";

const execAsync = promisify(exec);

export interface VulnerabilityReport {
  timestamp: string;
  scanType: "npm" | "container" | "dependency";
  vulnerabilities: {
    critical: number;
    high: number;
    moderate: number;
    low: number;
    info: number;
  };
  details: any[];
  passed: boolean;
}

export async function runNpmAudit(): Promise<VulnerabilityReport> {
  const report: VulnerabilityReport = {
    timestamp: new Date().toISOString(),
    scanType: "npm",
    vulnerabilities: { critical: 0, high: 0, moderate: 0, low: 0, info: 0 },
    details: [],
    passed: false,
  };

  try {
    const { stdout } = await execAsync("npm audit --json", {
      cwd: process.cwd(),
      maxBuffer: 10 * 1024 * 1024, // 10MB safety buffer
    });

    const auditResult = JSON.parse(stdout);

    if (auditResult.metadata?.vulnerabilities) {
      const vulns = auditResult.metadata.vulnerabilities;
      report.vulnerabilities = {
        critical: vulns.critical ?? 0,
        high: vulns.high ?? 0,
        moderate: vulns.moderate ?? 0,
        low: vulns.low ?? 0,
        info: vulns.info ?? 0,
      };
    }

    if (auditResult.vulnerabilities) {
      report.details = Object.values(auditResult.vulnerabilities);
    }

    report.passed =
      report.vulnerabilities.critical === 0 &&
      report.vulnerabilities.high === 0;

    securityLogger.info("NPM Audit completed", {
      vulnerabilities: report.vulnerabilities,
      passed: report.passed,
    });
  } catch (error) {
    securityLogger.error("NPM Audit failed", {
      error: error instanceof Error ? error.message : "Unknown error",
    });

    report.details.push({
      error: "Failed to run npm audit",
      message: error instanceof Error ? error.message : "Unknown error",
    });
    // Fail safe: mark as not passed
    report.passed = false;
  }

  return report;
}

export async function checkOutdatedDependencies(): Promise<VulnerabilityReport> {
  const report: VulnerabilityReport = {
    timestamp: new Date().toISOString(),
    scanType: "dependency",
    vulnerabilities: { critical: 0, high: 0, moderate: 0, low: 0, info: 0 },
    details: [],
    passed: true,
  };

  try {
    const { stdout } = await execAsync("npm outdated --json", {
      cwd: process.cwd(),
      maxBuffer: 5 * 1024 * 1024,
    });

    if (stdout.trim()) {
      const outdated = JSON.parse(stdout);
      report.details = Object.entries(outdated).map(([pkg, info]: [string, any]) => ({
        package: pkg,
        current: info.current,
        wanted: info.wanted,
        latest: info.latest,
        location: info.location,
      }));
      report.vulnerabilities.info = Object.keys(outdated).length;
    }

    securityLogger.info("Dependency check completed", {
      outdatedPackages: report.details.length,
    });
  } catch (error) {
    // npm outdated exits non-zero if there are outdated deps â†’ not fatal
    securityLogger.warn("Dependency check warning", {
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }

  return report;
}

export async function generateSecurityReport(): Promise<{
  timestamp: string;
  reports: VulnerabilityReport[];
  overallStatus: "passed" | "warning" | "failed";
  recommendations: string[];
}> {
  const reports: VulnerabilityReport[] = [];
  const recommendations: string[] = [];

  const npmReport = await runNpmAudit();
  reports.push(npmReport);

  const depReport = await checkOutdatedDependencies();
  reports.push(depReport);

  let overallStatus: "passed" | "warning" | "failed" = "passed";

  for (const report of reports) {
    if (!report.passed || report.vulnerabilities.critical > 0) {
      overallStatus = "failed";
      break;
    }
    if (report.vulnerabilities.high > 0 || report.vulnerabilities.moderate > 0) {
      overallStatus = "warning";
    }
  }

  if (npmReport.vulnerabilities.critical > 0) {
    recommendations.push("ðŸ”´ CRITICAL: Update packages with critical vulnerabilities immediately");
  }
  if (npmReport.vulnerabilities.high > 0) {
    recommendations.push("ðŸŸ¡ HIGH: Review and update packages with high vulnerabilities");
  }
  if (npmReport.vulnerabilities.moderate > 0) {
    recommendations.push("ðŸŸ  MODERATE: Consider updating packages with moderate vulnerabilities");
  }
  if (depReport.details.length > 0) {
    recommendations.push("ðŸ“¦ INFO: Consider updating outdated dependencies");
  }
  if (overallStatus === "passed") {
    recommendations.push("âœ… All security checks passed");
  }

  const securityReport = {
    timestamp: new Date().toISOString(),
    reports,
    overallStatus,
    recommendations,
  };

  await saveSecurityReport(securityReport);

  securityLogger.info("Security report generated", {
    overallStatus,
    totalVulnerabilities: reports.reduce(
      (sum, r) =>
        sum + Object.values(r.vulnerabilities).reduce((a, b) => a + b, 0),
      0,
    ),
  });

  return securityReport;
}

async function saveSecurityReport(report: {
  timestamp: string;
  reports: VulnerabilityReport[];
  overallStatus: string;
  recommendations: string[];
}): Promise<void> {
  try {
    const reportsDir = path.join(process.cwd(), "logs", "security-reports");
    await fs.mkdir(reportsDir, { recursive: true });

    const safeDate = new Date().toISOString().replace(/[:]/g, "-");
    const filename = `security-report-${safeDate}.json`;
    const filepath = path.join(reportsDir, filename);

    await fs.writeFile(filepath, JSON.stringify(report, null, 2));
    securityLogger.info("Security report saved", { filepath });
  } catch (error) {
    securityLogger.error("Failed to save security report", {
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
}

export function scheduleVulnerabilityScans(): void {
  setTimeout(() => {
    generateSecurityReport().catch((error) => {
      securityLogger.error("Scheduled security scan failed", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
    });
  }, 10_000);

  if (process.env.NODE_ENV === "production") {
    setInterval(() => {
      generateSecurityReport().catch((error) => {
        securityLogger.error("Daily security scan failed", {
          error: error instanceof Error ? error.message : "Unknown error",
        });
      });
    }, 24 * 60 * 60 * 1000);
  }

  securityLogger.info("Vulnerability scanning scheduled");
}
